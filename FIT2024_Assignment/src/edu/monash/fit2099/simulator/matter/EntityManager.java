package edu.monash.fit2099.simulator.matter;
import java.util.ArrayList;
import java.util.List;

import edu.monash.fit2099.simulator.space.Direction;
import edu.monash.fit2099.simulator.space.Location;
import edu.monash.fit2099.simulator.util.BiMultiMap;
/**
 * <code>EntityManager</code> stores an association between <code>Entities</code> and their <code>Locations</code>.
 * <p>
 * Generated by UML Lab
 * 
 * @author 	ram
 * @date 	17 February 2013
 * @see		{@link edu.monash.fit2099.simulator.matter.Entity}
 * @see		{@link edu.monash.fit2099.simulator.space.Location}
 */
/*
 * Changelog
 * 
 * 2013-03-04: made generic (ram)
 * 2013-03-08: made to depend on EntityInterface instead of Entity (ram)
 * 2013-04-09: added remove method (ram)
 * 2017-01-20: Extended the java doc for content method and added comments
 */

public class EntityManager<E extends EntityInterface, L extends Location> {
	
	/**
	 * A Bi Multi Map that is used to store the <code>Entities</code> mapped to their <code>Locations</code> on the map.
	 */
	private BiMultiMap<E, L> storage;
	
	/**
	 * Constructor for the <code>EntityManager</code>. 
	 * This method initializes the Bi Multi Map for storage of <code>Entities</code> on the map.
	 */
	public EntityManager() {
		storage = new BiMultiMap<E, L>();
	}
	
	/**
	 * Returns the <code>Location</code> of an <code>Entity e</code>, or null if the <code>Entity e</code> is not found on the map.
	 * 
	 * @author 	ram
	 * @param 	e the <code>Entity</code> to look for
	 * @return 	the <code>Location</code> of <code>e</code>, or null if <code>e</code> is not found on the map
	 */
	public L whereIs(E e) {
		return storage.get(e);
	}
	
	/**
	 * Removes the <code>Entity e</code> from the map. This method does nothing if the <code>Entity e</code> is not found on the map.
	 * 
	 * @author 	ram
	 * @param 	e the <code>Entity</code> to remove
	 */
	public void remove(EntityInterface e) {
		storage.remove(e);
	}
	
	/**
	 * This method will return,
	 * <ul>
	 * 	<li>a List containing all <code>Entities</code> in the target <code>Location loc</code> or</li>
	 * 	<li>an empty List if,</li>
	 * 		<ul>
	 * 			<li>no such <code>Location loc</code> is found or</li>
	 * 			<li>if there are no <code>Entities</code> in that <code>Location loc</code></li>
	 * 		</ul>
	 * </ul>  
	 * 
	 * @author 	ram
	 * @param 	loc Location being queried
	 * @return 	list of all <code>Entities</code> in <code>loc</code> or an empty list
	 */
	public List<E> contents(final L loc) {
		return storage.reverseLookup(loc);
		
	}
	
	/**
	 * Sets the new <code>Location</code> of <code>Entity e</code> to <code>Location loc</code>. This method will remove the 
	 * <code>Entity e</code> from its original location.
	 * 
	 * @param e the <code>Entity</code> to move
	 * @param loc the destination <code>Location</code>
	 */
	public void setLocation(E e, L loc) {
		storage.put(e, loc);
	}
	

	/**
	 * Allow time to pass.
	 * <p>
	 * Tells each <code>Entity</code> in the world to update itself and/or schedule an <code>Action</code>.
	 */
	public void tick() {
		
		//loop through all the Entities in the world
		for (E e: storage.keySet()) {
			e.tick(storage.get(e));
		}
	}
	
	/**
	 * Returns true if and only if the specified <code>Entity e</code> is in a <code>Location</code>
	 * that has a neighboring <code>Location</code> in the specified <code>Direction d</code>, false otherwise.
	 * 
	 * @author 	ram
	 * @param 	d <code>Direction</code> to check for exit
	 * @param 	e <code>Entity</code> in question
	 * @return 	true if and only if <code>e</code> can see an exit in <code>Direction d</code>
	 */
	
	public boolean seesExit(E e, Direction d) {
		return whereIs(e).hasExit(d);
	}
	
	/**
	 * Returns a list of <code>Actions</code> available to the given <code>Actor</code>.  
	 * <p>
	 * This includes <code>Actions</code> intrinsic to the <code>Actor</code> as well as <code>Affordances</code> 
	 * belonging to other <code>Entities</code> in the same <code>Location</code>.  No checking is done as to
	 * whether the <code>Actor</code> can actually perform the <code>Actions</code>.</p>
	 * 
	 * @author 	ram
	 * @param 	a the <code>Actor</code> for whom the the list of <code>Actions</code> is required
	 * @return 	List<Action> of possible <code>Actions</code>
	 * 
	 * @modified dsquire 20130416
	 *  - added check so that the actor's own affordances aren't added to this list of things it can do.
	 *    Affordances are things that can be done *to* an entity, not by it.
	 *    
	 *    Can we move this to the change log? - Asel
	 */
	/*
	 * This code has a couple of unchecked casts.  They can't be checked because
	 * generics are involved.
	 */
	@SuppressWarnings("unchecked")
	public <A extends ActionInterface> List<A> getActionsFor(Actor<A> a) {
		ArrayList<A> theActions = new ArrayList<A>();
		
		//Actions for the Actor a
		for (A ac: a.getActions()) {
			theActions.add(ac);
		}
		

		L loc = whereIs((E) a);
		//Affordances of the Entities in the same location
		for (E e: contents(loc)) {
			if (e != a) { //don't add the affordances if they belong to the actor itself
				for (Affordance aff: e.getAffordances()) {
					theActions.add((A) aff);
				}
			}
		}
		
		
		return theActions;
	}
}
